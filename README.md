![배너.png](/ReadMeSource/banner_resize.png)

- 태그: 3인칭, RPG
- 사용 프로그램: Unreal Engine 5, VisualStudio 2022, Github, Notion
- 팀 구성: 프로그래머 1인 개발
- 플랫폼: PC
- 작업 기간: 2025년 1월 → 2025년 2월
<br>


## ❗개요
- **Unreal Engine 5를 사용한 PC(Windows)기반 3인칭 액션 RPG 게임.**
- 중세 시대를 배경으로 하나의 스테이지를 구현하는 것을 목표로 하고 있습니다. 현재 전투 프로토타입까지 개발을 완료했으며, 추가 기능들은 이후 확장해 나갈 예정입니다.
- 대부분의 기능은 C++로 제작하였으며, 객체지향 원칙을 준수하고자 노력했습니다.
<br>


## 📜 주요 기능
- 전투 시스템
    - 플레이어 및 몬스터 사망 처리
    - 스탯 컴포넌트
    - 공격 컴포넌트
    - 무기 클래스
    - 피격 컴포넌트
    - 타겟팅 시스템
- AI
    - 일반 몬스터
    - 보스 몬스터
- 인벤토리 시스템
- 애니메이션
    - 모션 매칭
- 기타
    - 사운드 및 이펙트 적용
<br>


## 🖥️ 개발 내용

### 플레이어 및 몬스터 사망처리 - 글로벌 이벤트

 `UIVDeathEventSubsystem`는 플레이어의 사망, 부활, 몬스터의 사망 정보를 전달하는 글로벌 이벤트 시스템입니다.  UGameInstanceSubsystem를 상속받아 게임의 시작부터 종료까지 유지됩니다.

 싱글 플레이 게임에서 플레이어의 사망 및 부활은 중요한 이벤트이며, 이에 따라 플레이어 캐릭터, 컨트롤러, HUD, 스탯 등 다양한 요소들이 영향을 받습니다. 그렇기에 개별 캐릭터에서 이벤트를 관리하지 않고, 별도의 글로벌 이벤트 시스템을 만들어 관리하였습니다.

 `UIVDeathEventSubsystem`에는 해당 이벤트와 관련된 대리자가 선언되어 있습니다. 위의 상황이 발생하면 각 객체의 스탯 컴포넌트에서 이벤트를 발동시키고, 이를 구독하는 여러 시스템들이 독립적으로 처리를 수행합니다. 

 몬스터의 사망 또한 글로벌 이벤트로 처리하는 이유는 보스 룸과 타겟팅 시스템이 특정 몬스터의 사망에 영향을 받기 때문입니다. 또한, 확장이 용이하기에 이후 몬스터 처치 퀘스트 등에 활용하고자 글로벌 이벤트로 처리하고 있습니다. 
 
<br>


### 스탯 컴포넌트

 스탯 컴포넌트는 플레이어와 몬스터 캐릭터에 부착되어 이들의 스탯을 관리하고 사망 판정을 진행하는 역할을 수행합니다. 공통 요소를 관리하는 `UIVBaseStatComponent`를 상속받아 플레이어에 특화된 `UIVCharacterStatComponent`와 몬스터에 특화된 `UIVMonsterStatComponent`로 분리하여 사용합니다.

 `UIVBaseStatComponent`는 모든 캐릭터와 아이템이 가지는 기본 스텟 구조체 `FBaseStat`와 데미지 관련 구조체인 `FBaseDamageStat`를 소유합니다. 이들은 연산자 오버로딩을 활용해 구조체 단위로 연산을 진행합니다. 스탯 정보 변경 및 사망 이벤트 발생 시, 이를 글로벌 이벤트 시스템에 전달하는 역할 또한 수행합니다.

 `UIVCharacterStatComponent`는 `IVCharacterStateEnums`에서 확인 가능한 플레이어 동작 상태들을 추가로 관리합니다. `IIIVCharacterComponentProvider` 인터페이스를 사용해 캐릭터 스탯 컴포넌트에 접근할 수 있으며, 애님 인스턴스와 모션 매칭을 위한 Chooser가 이 정보들을 활용합니다. 

 `UIVMonsterStatComponent`는 캐릭터 스탯 컴포넌트와 조금 방식으로 작동합니다. 몬스터의 상태를 나타내는 `EMonsterState`를 몬스터 스탯 컴포넌트에서 관리하려 했으나, 행동 트리와 역할이 겹쳐 불필요한 복잡성이 발생했기 때문입니다. 결국 몬스터의 상태는 블랙보드의 키값으로써 행동 트리와 AI 컨트롤러가 제어를 담당하고, 몬스터 스탯 컴포넌트는 몬스터 캐릭터와 AI 컨트롤러를 위한 사망 및 체력 정보 전달만을 수행합니다.  

<br>


### 무기 클래스

 `AIVWeapon` 클래스는 캐릭터의 공격 동작과 데미지 처리를 담당하는 핵심 클래스입니다. 공격 관련 데이터인 데미지 스탯, 애니메이션, 메쉬, 콜라이더, 사운드, 이펙트를 관리하며, 공격 시 충돌 감지, 데미지 연산 및 전달 기능을 수행합니다.

![relation.png](/ReadMeSource/relation.png)

 캐릭터의 공격 명령이 공격 컴포넌트를 거쳐 무기에 전달되면, 무기는 이번에 재생될 공격 몽타주를 제공합니다. 해당 몽타주에는 UAnimNotifyState를 상속받은 `UIVWeaponHitDetection`가 존재하여 매 틱마다 충돌 검사를 진행합니다. 

 한 번의 공격은 여러 틱에 걸쳐 진행되므로, 이전 틱에 충돌했던 물체가 이번 틱에 다시 충돌할 수도 있습니다. 그렇기에 이번 공격에서 충돌했던 액터 목록인  `TArray<AActor*> HitActors`를 사용하여 해당 물체와 최초 충돌하는 경우에만 데미지를 전달합니다. 

 충돌 판단에는 캡슐 콜라이더를 활용합니다. 다만, SweepMultiByObjectType()에서 그 위치와 모양을 가져와 검사를 진행하며 캡슐 콜라이더 자체는 충돌 판단을 하지 않습니다. 

 기존에는 단일 콜라이더로 공격을 처리하려 했으나, 하나의 무기가 여러 타격점을 가지는 경우 문제가 발생했습니다. 그렇기에 캡슐 컴포넌트를 상속받은 `UIVAttackRange`를 만들고, 블루프린트에서 타격점마다 컴포넌트 부착 후 위치와 크기를 조정했습니다. 무기는 게임이 시작되기 전 배열에 모든 공격 범위 컴포넌트를 저장하여 충돌 검사에 사용합니다.

 몬스터를 제작하다 보니 공격 지점이 무기가 아닌 캐릭터에 종속적인 경우가 있었습니다. 그래서 캐릭터에도 공격 범위 컴포넌트를 부착하고, 무기를 장착했을 때 해당 목록을 무기에 전송하도록 했습니다. 이 경우 무기와 캐릭터의 공격 범위 모두에서 충돌 검사를 진행합니다.

<br>


### 공격 컴포넌트

 `UIVAttackComponent`는 플레이어와 몬스터에 부착되어 캐릭터와 무기 사이에서 공격 기능을 수행합니다.

 캐릭터는 공격 명령을 내리고 무기는 충돌 판정 및 데미지 전달을 수행할 때, 공격 컴포넌트는 그 사이에서 공격 명령 및 스탯 전달, 공격 동작 및 공격 콤보 관리를 전담합니다. 캐릭터에서 공격 관련 요소들을 별도로 관리하기 위해 만들었습니다.

 공격 컴포넌트는 무기를 기반으로 작동합니다. 설령 맨손일지라도 공격을 진행하기 위해서는 데이터를 가진 무기 장착이 요구됩니다. 캐릭터는 `UIVEquipComponent`에서 무기를 장착하고, 이 정보를 공격 컴포넌트에 전달합니다. 공격 컴포넌트는 `IIIVWeaponInterface`를 통해 해당 무기의 콤보 및 몽타주 정보를 가져와 공격을 진행합니다.

![combo.png](/ReadMeSource/combo.png)

 콤보 공격은 마지막 공격이 종료된 이후 일정 시간 내에 다시 공격을 입력하면, 다음 동작으로 연계되는 공격을 의미합니다. 각 무기에는 지정된 콤보 몽타주가 있으며, 몽타주의 갯수가 곧 해당 무기의 최대 콤보 수가 됩니다. 공격 컴포넌트는 콤보 카운트와 콤보 리셋 타이머를 통해 이를 관리합니다.

 공격 몽타주가 끊김 없이 재생된다면 미리 지정해둔 `UIVAttackEndNotify`가 발동됩니다. 이는 `IIIVAttackEndInterface`를 통해 캐릭터의 공격 종료 함수를 호출하고, 공격 컴포넌트의 콤보 타이머를 작동시킵니다.

 그러나 공격 도중 피격이 발생하면 상황이 달라집니다. 피격 동작은 다른 동작들보다 우선순위가 높기에, 진행 중인 공격 몽타주를 중단하고 피격 몽타주를 재생하기 때문입니다. 이로 인해 노티파이가 발동되지 않을 경우, 몽타주 종료 대리자를 사용하여 동일한 기능을 수행합니다.

<br>


### 피격 컴포넌트

 `UIVHitReactionComponent`는 플레이어와 몬스터에 부착되어 피격 반응을 관리합니다. 피격 반응 변수 설정에 따라 피격 사운드, 이펙트에 더하여 사망 애니메이션이나 방향별 피격 애니메이션 재생 여부가 결정됩니다.

 피격 컴포넌트는 크게 피격 각도 계산과 각도에 해당하는 애니메이션 재생 부분으로 구성됩니다. 피격 각도는 피격된 캐릭터의 정면 방향과 데미지 전달 방향 간의 내적을 통해 계산하며, 외적을 통해 공격의 좌우 방향 판단까지 진행합니다.

 이렇게 계산된 각도를 기준으로 재생할 피격 애니메이션을 선택합니다. 피격 애니메이션은 90도 간격으로 구분되어 있으며, 전후좌우 4방향에 대해 몽타주를 지정할 수 있습니다. 애니메이션이 선택되면 해당 애니메이션의 재생 및 종료 정보 전달까지 피격 컴포넌트에서 수행합니다. 

<br>


### 타겟팅 시스템

 타겟팅 시스템은 특정 대상을 타깃으로 지정하여 플레이어 컨트롤러의 정면을 타깃 방향으로 고정하는 기능입니다. 플레이어 캐릭터의 고유 기능이기에 별도의 컴포넌트로 분리하지 않았습니다.

 타겟팅 대상은 3가지 조건을 만족해야 합니다. `IIIVLockOnTargetMarker` 인터페이스를 구현하고, 플레이어와 대상 사이에 장애물이 없어야 하며, 타겟팅 범위 내 대상 중 플레이어와 가장 가까이 위치하는 것이 그 조건입니다.

 타깃으로 선정되면 플레이어의 HUD 상에서 타깃의 좌표에 마커 위젯이 부착됩니다. 마커가 활성화되어있는 동안 매 틱마다 위치가 갱신됩니다.

 논타겟 상태에서는 컨트롤러의 정면 방향을 캐릭터의 정면으로 하되, 이동 시 캐릭터가 움직이는 방향을 향해 회전하는 방식을 사용합니다. 일반적인 타겟팅 상태에서는 캐릭터와 컨트롤러가 타깃만을 바라보지만, 저는 논타겟 상태처럼 캐릭터가 이동 방향을 바라보게 하고 싶었습니다. 그렇기에 회전 보정을 적용했습니다. 타겟팅 시 컨트롤러는 매 틱마다 타깃의 위치를 향해 회전하고, 캐릭터는 움직임 입력이 들어오는 동안 이동 방향으로 회전을 진행하여 이를 구현했습니다. 

<br>


### 일반 몬스터 AI

 `AIVEnemy`는 몬스터의 기본이 되는 클래스입니다. 플레이어 캐릭터와 동일하게 `AIVCharacterBase`을 상속받으며, 공격, 피격, 장비 등의 컴포넌트 부착과 인터페이스 구현에서 겹치는 부분이 많습니다. 한 편 체력 위젯 관리나 컨트롤러 부분에서 차이가 존재합니다.

 가장 큰 차이는 행동 트리와 블랙보드가 추가되며 행동의 결정과 수행이 분리된 것입니다. 예를 들어 스켈레톤 몬스터가 플레이어를 탐지하고 행동하는 과정은 다음과 같습니다. 

1. AI 컨트롤러에서 UAIPerceptionComponent를 사용해 플레이어를 인식합니다.
2. AI 컨트롤러에서 블랙보드의 키값을 변경해 공격 대상을 지정합니다.
3. 행동 트리에서 블랙보드 키 변경에 따라 다른 태스크를 실행합니다.
4. 행동 트리에서 인터페이스를 통해 캐릭터의 동작을 실행합니다.
5. 캐릭터는 동작을 수행하고, 완수 시 AI 컨트롤러에 정보를 전달합니다.
6. AI 컨트롤러는 다시 블랙보드의 키값을 변경하며 위의 과정을 반복합니다. 

 행동 트리는 행동을 결정하고, 캐릭터는 이를 수행하며, 컨트롤러는 블랙보드 키 제어를 통해 행동 트리에 영향을 미치는 과정이 반복됩니다.

<br>


### 보스 몬스터 AI

 보스 몬스터는 고유한 특수 이동과 특수 공격을 보유한 몬스터입니다. 해당 기능은 캐릭터 종속적이기에 기존 무기 클래스와 어울리지 않았습니다. 그렇기에 따로 일반 몬스터 캐릭터와 컨트롤러를 상속받아 `AIVBossEnemy`와 `AIVBossAIController`를 만들었으며, 행동 트리와 연결하기 위해 각각 `IIIVAICharacterSpecialCombat`, `IIIVAIControllerSpecialCombat` 인터페이스를 구현했습니다.

 전투 프로토타입 영상에서 확인할 수 있는 보스는 램페이지입니다. 이 보스는 플레이어와의 거리를 기반으로 서로 다른 동작을 수행하도록 설계되었습니다. 각 거리 범위에서 데코레이터를 활용해 자식 노드를 랜덤하게 선택하는 방식으로 행동의 다양성을 높였습니다. 

- 근거리 - 무기에 등록된 일반 공격을 수행합니다.
- 중거리 - 플레이어에게 접근하거나 특수 공격을 수행합니다. 특수 공격은 보스 중심의 범위 공격입니다.
- 원거리 - 잠시 대기하거나 특수 이동을 수행합니다. 특수 이동은 현재 플레이어 위치로 도약하는 범위 공격입니다.

 특수 이동은 LaunchCharacter()와 모션 워핑을 혼합하여 사용했습니다. LaunchCharacter()만 사용하면 회전 동작이 어색했고, 모션 워핑만 사용하면 도약 높이 조절이 원활하지 않았기 때문입니다. 

 또한, 보스룸 액터를 제작하여 플레이어의 보스룸 출입 이벤트와 전투 배경음 재생, 보스 정보 전달 기능 등을 수행합니다.

<br>


### 인벤토리 시스템

![inventory_widget.png](/ReadMeSource/inventory_widget.png)

인벤토리 시스템은 플레이어가 아이템과 상호작용하기 위한 기능을 담당합니다. 플레이어가 인벤토리 위젯을 조작하면, 연결된 컴포넌트에서 아이템을 줍거나 버리고, 사용하거나 장착하는 등의 로직이 실행됩니다.

 아이템은 무기, 방어구, 소모품의 세 가지로 구분되며, 각 아이템의 핵심 정보는 `FItemBaseInfo` 구조체에 정의됩니다. 이 구조체들을 관리하기 위한 데이터베이스가 존재하며, 게임 인스턴스 서브시스템을 상속받은 `UIVDatabaseSubsystem` 을 통해 손쉽게 접근할 수 있도록 구성했습니다. 

 인벤토리 위젯은 역할에 따라 계층적으로 구성되어 있습니다. 인벤토리 창이 위치할 수 있는 캔버스인 베이스, 플레이어가 보는 인벤토리 창인 위젯, 이에 부착되어 아이템의 아이콘과 수량을 표시하는 슬롯으로 나타납니다. 플레이어는 더블 클릭 혹은 드래그 앤 드롭을 통해 UI와 상호작용하며, 슬롯 타입과 계층별로 다른 동작을 수행합니다. 

 이 시스템에 연관된 컴포넌트는 스탯, 장비, 인벤토리로 나뉘며, 각 컴포넌트는 소유자인 캐릭터가 구현한 인터페이스를 통해 서로 접근합니다. 인벤토리 컴포넌트는 아이템을 저장하기 위한 배열과 변경 사항을 알리는 대리자를 보유하고 있으며, 슬롯 타입에 따라 이들에 접근할 수 있는 별도의 기능을 가집니다. 대부분의 기능은 슬롯 타입과 아이템 인덱스를 인자로 받아 처리되며, 위젯으로부터 전달받는 정보 또한 이 두 값으로 구성됩니다. 이를 바탕으로 아이템의 사용, 제거, 스왑 등 다양한 동작을 수행할 수 있도록 구성했습니다.

<br>

### 모션 매칭

 플레이어 캐릭터에는 모션 매칭을 적용했습니다. 점프, 걷기, 달리기, 대기 상태로 구분하여 포즈 서치 데이터베이스를 생성했으며, 캐릭터 스탯 컴포넌트의 상태 정보를 활용하여 Chooser에서 적합한 데이터베이스를 선택하도록 지정했습니다. 

 작업을 진행하며 단일 포즈 데이터베이스보다 다양한 포즈 데이터베이스를 운용하는 편이 좋다는 것을 알 수 있었습니다. 특정 상황에서 원하지 않는 애니메이션들이 재생되는 문제가 있었기에, 리와인드 디버거를 활용하여 문제가 되는 애니메이션들을 파악하고 데이터베이스에서 제거하여 자연스러운 동작을 만들었습니다.

<br>


## 🕹️ 인게임 영상
[![포트폴리오 영상](/ReadMeSource/youtube.png)](https://www.youtube.com/watch?v=xWUeNQMD1T8&t=69s&ab_channel=Whale_log)
