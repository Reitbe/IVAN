![배너.png](/ReadMeSource/banner_resize.png)

- 태그: 3인칭, RPG
- 사용 프로그램: Unreal Engine 5, VisualStudio 2022, Github, Notion
- 팀 구성: 프로그래머 1인 개발
- 플랫폼: PC
- 작업 기간: 2025년 1월 → 2025년 4월
<br>


## ❗개요
- **Unreal Engine 5를 사용한 PC(Windows)기반 3인칭 액션 RPG 게임.**
- 중세 시대를 배경으로 하나의 스테이지를 구현하는 것을 목표로 제작했습니다. RPG 장르의 주요 기능들을 중심으로 구현했습니다.
- 대부분의 기능은 C++로 제작하였으며, 객체지향 원칙을 준수하고자 노력했습니다.
<br>

## 📜 목차
- 인벤토리 시스템
- 대화 시스템
- 조건 확인 시스템
- 전투 시스템
- 상호작용 시스템
- 타겟팅 시스템
- 세이브 로드 시스템
- 일반 몬스터 AI - Skeleton
- 보스 몬스터 AI - Rampage
- 모션 매칭
- 기타) 캐릭터 구성도
- 🕹️ 인게임 영상
<br>


## 🖥️ 개발 내용

### 인벤토리 시스템

![1.InventorySystem.png](/ReadMeSource/1.InventorySystem.png)

 인벤토리 시스템은 플레이어가 습득한 아이템을 관리하고, 사용할 수 있도록 지원하는 기능입니다.

 플레이어가 아이템과 상호작용하면, 해당 아이템은 `InventoryComponent` 내부에 존재하는 타입별 배열에 저장됩니다. 이 배열은 인벤토리 위젯을 통해 화면에 표시되며, 드래그 앤 드롭이나 더블클릭 조작을 통해 아이템을 이동하거나 사용할 수 있습니다. 

 인벤토리 시스템에서 중요하게 생각한 것은 슬롯 타입에 독립적인 범용 연산 구조입니다. 대부분의 함수가 슬롯 타입과 슬롯 인덱스를 인자로 받아 로직을 실행하도록 설계했습니다. 
```cpp
// IVInventoryComponent.cpp
bool UIVInventoryComponent::SwapInventorySlot(EInventorySlotType FromSlotType, int32 FromSlotIndex, EInventorySlotType ToSlotType, int32 ToSlotIndex)
{
	TArray<FItemBaseInfo>* FromSlotArray = IsValidSlot(FromSlotType, FromSlotIndex);
	TArray<FItemBaseInfo>* ToSlotArray = IsValidSlot(ToSlotType, ToSlotIndex);

	// 슬롯 유효성 검사
	if(!FromSlotArray || !ToSlotArray)
	{
		return false;
	}

	// 스왑할 슬롯과 아이템 타입 호환 검사
	if (!CanSwapSlot(FromSlotType, FromSlotIndex, ToSlotType, ToSlotIndex))
	{
		return false;
	}

	// 슬롯간 교환 처리
	FItemBaseInfo TempItem = (*FromSlotArray)[FromSlotIndex];
	(*FromSlotArray)[FromSlotIndex] = (*ToSlotArray)[ToSlotIndex];
	(*ToSlotArray)[ToSlotIndex] = TempItem;

	// 슬롯에 맞는 인벤토리 갱신
	if (FromSlotType != ToSlotType)
	{
		NotifySlotUpdated(FromSlotType);
		NotifySlotUpdated(ToSlotType);
	}
	else
	{
		NotifySlotUpdated(FromSlotType);
	}

	return true;
}
```

 특히 슬롯 타입을 기준으로 인벤토리 배열과 대리자에 접근할 수 있는 별도의 TArray와 함수를 만들어 사용했습니다. 이 배열의 인덱스로는 아이템 타입 Enum을 int32 타입으로 캐스팅해 사용했으며, 값으로는 개별 인벤토리 및 대리자의 주소를 지정했습니다.

<br>

### 대화 시스템

![2-1.DialogueSystem.png](/ReadMeSource/2-1.DialogueSystem.png)

 대화 시스템은 플레이어가 주변 NPC들로부터 정보를 얻고, 분기에 따른 선택지를 통해 게임의 흐름을 만들어 나가기 위한 기능입니다.

 플레이어가 대화 컴포넌트를 가진 NPC와 상호작용하면 대화 위젯이 활성화되고, ‘다음’ 버튼이나 제시된 선택지를 클릭하여 대화를 이어 나갈 수 있습니다.

 이 시스템에서 중점을 둔 부분은 중앙 집중식 관리입니다. NPC는 대화용 ID와 대화 시작 권한만을 보유하며, 실제 대화의 진행은 대화 매니저 서브시스템(`UIVDialogueManagerSubsystem`)이 담당합니다. 

 대화 데이터는 연결 리스트 구조로 구성되어 있습니다. 각 대화 구조체는 다음에 이어질 대화 ID를 포함하고 있기에, 대화의 시작 지점만 알면 전체 대화 DB에서 다음 대화를 찾아 대화를 이어 나갈 수 있습니다. 이를 위해 전체 대화 DB 이외에 NPC별 대화 시작 지점 목록 DB를 구성하였습니다.

 대화 매니저는 두 차례에 걸쳐 DB 서브시스템에 접근합니다. 1차 접근에서는 상호작용한 NPC의 대화 시작 지점 목록을 가져오고, 이를 조건 확인 매니저에 전달하여 현 상태에 맞는 대화 시작 지점을 결정합니다. 이후 2차 접근에서 대화 데이터를 가져와 위젯에 출력함으로써 플레이어와의 대화가 시작됩니다.

![2-2.DialogueUIUpdate.png](/ReadMeSource/2-2.DialogueUIUpdate.png)

  대화 매니저와 위젯은 서로 대리자를 사용해 통신합니다. 위젯 내부에서 하위 요소로 대화 내용을 전파할 때는 함수의 인자를 사용했지만, 역으로 다음 대화 ID를 상위 요소로 전파할 때는 대리자를 통해 전달하도록 구현했습니다.

<br>

### 조건 확인 시스템

![3.ConditionCheckSystem.png](/ReadMeSource/3.ConditionCheckSystem.png)

 조건 확인 시스템은 대화나 퀘스트 등에서 다양한 조건 목록을 전달받아, 해당 조건의 충족 여부 혹은 특정 항목을 선택해 반환하는 기능입니다. 다양한 외부 조건들을 한곳에 모아 검사하기 위해 만들었습니다. 

 이 시스템에서 중점을 둔 것은 범용성입니다. 스테이지 정보, 플레이어 상태, 아이템 보유 여부 등 서로 다른 유형의 데이터를 받아 검사할 수 있어야 했습니다. 이에 행동 트리의 데코레이터를 참고하여 구조를 설계했습니다.

 데코레이터는 Key-Operation-Value 형태의 3가지 값을 조합하여 조건 만족을 확인합니다. 이를 모방하여 Type-Operation-Value 값을 가지는 조건 검사 구조체와 Type과 Operation의 Enum을 정의했습니다. 조건 확인 시스템은 우선 Type에 따라 검사 함수를 선택하고, 함수 내부에서 Operation에 매핑된 연산자를 실행해 결과를 반환합니다.

 초기 구현에서는 모든 Value를 단일 텍스트 필드로 처리했었습니다. 그러나 아이템 보유 수량 검사처럼 두 개의 값이 필요한 때도 있었으며, 일부 타입은 값을 캐스팅하여 사용해야 한다는 문제가 있었습니다. 이를 개선하기 위해 조건 검사 구조체에 다양한 Value 필드를 미리 정의하고, Type에 따라 필요한 필드만 활성화 되도록 설정하였습니다.

<br>

### 전투 시스템

![4.CombatSystem.png](/ReadMeSource/4.CombatSystem.png)

 전투 시스템은 플레이어와 몬스터 간의 공격, 피격, 그에 따른 스탯과 사망 처리를 담당하는 기능입니다. 플레이어와 몬스터 모두 동일한 구조를 따릅니다. 

 이 시스템에서는 진행 과정에서의 역할 분리를 중요하게 생각했습니다. `StatComponent`는 캐릭터 상태 및 스탯 처리를, `AttackComponent`는 공격 진행에 필요한 몽타주 재생 및 콤보 관리를, `Weapon`은 몽타주와 같은 데이터 보유 및 충돌 처리와 데미지 연산을 수행합니다. 

 공격 종료 함수는 노티파이와 몽타주 종료 대리자를 사용하여 두 번 실행되도록 설계했습니다. 노티파이는 호출되기 전까지 새로운 공격 입력을 방지하고, 애니메이션이 끝나기 전에 콤보를 이어 나갈 수 있도록 하는 역할을 수행합니다. 몽타주 종료 대리자는 공격보다 피격 처리의 우선순위가 높기 때문에 사용합니다. 공격 도중 피격을 당했을 때, 노티파이가 실행되기 이전에 공격 몽타주가 종료되어 공격 상태가 끝나지 않는 상황을 방지하기 위해 사용합니다. 

 공격 범위는 `AttackRange`라는 캡슐 콜라이더를 따라 결정되며, 각 콜라이더의 위치와 모양은 블루프린트에서 조정할 수 있습니다. 초기 구현에서는 캐릭터가 단일 공격 범위를 가지는 단일 무기를 사용하도록 했었습니다. 그러나 무기가 둘 이상의 타격점을 가지는 경우가 있었고, 나아가 캐릭터의 신체 부위에 공격 범위를 부착해야 하는 경우도 있었습니다. 이를 개선하기 위해 캐릭터와 무기 모두 `AttackRange` 콜라이더 배열을 가지도록 변경하였으며, 무기는 캐릭터의 콜라이더 배열을 전달받아 모든 콜라이더를 순회하며 데미지 처리를 진행하도록 수정하였습니다.

<br>

### 상호작용 시스템

![5.InteractionSystem.png](/ReadMeSource/5.InteractionSystem.png)

 상호작용 시스템은 플레이어와 상호작용하는 각 대상이 특정 동작을 수행하도록 하는 기능입니다. 플레이어는 상호작용 컴포넌트를 통해 범위 내의 대상을 탐지하고, 각 대상이 구현한 상호작용 인터페이스의 `Interact()` 함수를 호출합니다. 

 상호작용 인터페이스를 구현하는 대상은 NPC, ItemBase, SavePoint입니다. 이들은 `Interact()`에서 각각 대화, 인벤토리에 아이템 추가, 세이브 기능을 실행합니다. 

 플레이어와 대상은 모두 범위 콜라이더를 가지지만 다른 역할을 수행합니다. 플레이어의 콜라이더는 범위 내의 대상을 탐색하는 용도이며, 대상의 콜라이더는 플레이어 진출입 시 상호작용 위젯을 관리하는 용도입니다.

<br>

### 타겟팅 시스템

![6.TargettingSystem.png](/ReadMeSource/6.TargettingSystem.png)

 타겟팅 시스템은 주변에서 가장 가까운 대상을 탐지하고, 그 위치를 기준으로 플레이어의 움직임을 변경하는 기능입니다. 타겟팅이 활성화되면 플레이어 컨트롤러가 대상의 방향으로 고정되고, 대상을 식별할 수 있는 마커가 부착됩니다.

 이 시스템에서 고려한 점은 캐릭터 페이싱 방식의 선택입니다. 캐릭터가 컨트롤러와 같이 고정된 정면을 사용할지, 아니면 이동 방향에 따라 자유롭게 페이싱 방향을 전환할지 고민했습니다. 초기에는 자유 페이싱 방식에 단일 앞구르기 동작을 사용했었으나, 공격의 어려움과 방향 제어의 복잡성 때문에 고정 페이싱 및 4방향 구르기 동작 사용 방식을 채택했습니다.

 또한, 단순히 지정된 애니메이션을 재생하는 대신, 이동 방향과 캐릭터의 정면 방향을 모두 고려하여 적합한 구르기 몽타주를 선택하도록 했습니다. 

<br>

### 세이브 로드 시스템

![7.SaveLoadSystem..png](/ReadMeSource/7.SaveLoadSystem.png)

 세이브 로드 시스템은 게임의 진행 정보를 저장하고, 게임 시작 또는 플레이어 리스폰 시 해당 상태를 복원하기 위한 기능입니다. 

 저장은 레벨에 배치된 세이브 포인트를 통해 진행합니다. 저장 시 세이브 포인트와 상호작용한 플레이어의 위치가 기록되며, 이후 리스폰 시 게임모드는 이 위치를 기반으로 새 캐릭터를 생성합니다. 

 세이브 데이터에는 4종류의 인벤토리 배열이 포함되어 있습니다. 이들의 로드 과정에서는 단순 데이터 복사를 넘어서 장비의 장착과 위젯 갱신이 필요합니다. 이를 위해 방어구, 무기, 퀵슬롯 배열에 저장된 각 아이템을 공용 슬롯 배열의 0번 위치에 복사한 뒤, 드래그 앤 드롭 로직을 사용하여 기존의 위치에 배치했습니다. 공용 슬롯 배열은 별도의 처리 없이 전체 복사 후 한 번의 위젯 갱신으로 결과가 반영되도록 했습니다. 

<br>

### 일반 몬스터 AI - Skeleton

![9.SkeletonMonster.png](/ReadMeSource/9.SkeletonMonster.png)

 Skeleton은 일반 몬스터 타입으로써 기본적인 배회, 추적, 공격 동작을 수행합니다. 

 AI 시스템은 행동 트리, AI 컨트롤러, 몬스터 캐릭터의 세 부분으로 구성됩니다. 행동트리는 몬스터 상태 Enum을 기반으로 다음 동작을 결정합니다. AI 컨트롤러는 인식 정보 및 캐릭터 동작 상태를 기반으로 몬스터 상태를 갱신하며, 몬스터 캐릭터는 명령에 따라 동작을 수행합니다. 몽타주의 시작과 끝 시점에 상태가 변화하므로, 컨트롤러를 경유하여 이를 행동 트리에 전달할 필요가 있습니다.

 이때, 캐릭터와 컨트롤러 & 행동트리를 분리하기 위해 인터페이스를 사용했습니다. 몬스터 캐릭터는 `AICharacterBasicCombat` 인터페이스를, AI 컨트롤러는 `AIControllerBasicCombat` 인터페이스를 구현하여, 명령과 상태 변경 정보를 전달하도록 했습니다. 위젯 컨트롤 인터페이스는 전투 인터페이스와 독립적으로 작동합니다.

<br>

### 보스 몬스터 AI - Rampage

![10.LampageMonster.png](/ReadMeSource/10.LampageMonster.png)

 보스 몬스터는 일반 몬스터를 기반으로 하되, 보스 고유의 특수 행동 패턴을 가집니다. 이는 무기를 기반으로 하는 기존의 일반 공격과 다른 것이며, 특수 행동 명령 및 상태 변경 정보를 전달하는  `AICharacterSpecialCombat`, `AIControllerSpecialCombat` 인터페이스 구현을 통해 이루어집니다.

 Rampage는 플레이어와의 거리에 따라서 다른 공격을 수행합니다. 근거리에서는 일반 공격, 중거리에서는 제자리에서 땅을 내려 찍는 특수 공격, 원거리에서는 플레이어 위치로 점프하여 땅을 내려 찍는 특수 이동을 수행합니다.  

 특수 이동은 모션 워핑과 `LaunchCharacter()`를 사용하여 동작을 구현했습니다. 모션 워핑만을 사용하는 경우, 그래프를 사용한 이동 속도 제어와 회전이 가능했지만 점프 높이 조절이 문제가 되었습니다. 이를 해결하기 위해 특수 이동 몽타주를 점프와 비행 및 착지의 두 부분으로 나누었습니다. 점프 부분에서는 모션 워핑을 사용하여 짧은 시간동안 플레이어를 향해 회전하도록 하였으며, 비행 및 착지 부분에서는 `LaunchCharacter()`를 사용하여 Rampage를 원하는 높이와 거리만큼 움직이도록 처리했습니다.

<br>

### 모션 매칭

 플레이어 캐릭터에는 모션 매칭을 적용했습니다. 점프, 걷기, 달리기, 대기 상태로 구분하여 포즈 서치 데이터베이스를 생성했으며, 캐릭터 스탯 컴포넌트의 상태 정보를 활용하여 Chooser에서 적합한 데이터베이스를 선택하도록 지정했습니다. 

 작업을 진행하며 단일 포즈 데이터베이스보다 다양한 포즈 데이터베이스를 운용하는 편이 좋다는 것을 알 수 있었습니다. 특정 상황에서 원하지 않는 애니메이션들이 재생되는 문제가 있었기에, 리와인드 디버거를 활용하여 문제가 되는 애니메이션들을 파악하고 데이터베이스에서 제거하여 자연스러운 동작을 만들었습니다.

<br>

### 기타) 캐릭터 구성도

![8.CharacterStructure.png](/ReadMeSource/8.CharacterStructure.png)


<br>


## 🕹️ 인게임 영상
[![포트폴리오 영상](/ReadMeSource/youtube_thumbnail_v3.png)](https://youtu.be/RglodEyCVSI?si=qzDrUYeVzTtlYeXa)
